#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
xdat <- ECG_measurements[,"channel1"]
dt <- ECG_measurements[2,"time"] - ECG_measurements[1,"time"]
stackmax <- 25
rmax <- 5
lambda <- .001
hav <- havok(xdat = xdat, dt = dt, stackmax = stackmax, lambda = lambda,
rmax = 5, polyOrder = 1, useSine = FALSE)
plot(hav)
devtools::check()
document()
rm(list = c("havok"))
document()
build()
check()
xdat <- ECG_measurements[,"channel1"]
dt <- ECG_measurements[2,"time"] - ECG_measurements[1,"time"]
stackmax <- 25
rmax <- 5
lambda <- .001
hav <- havok(xdat = xdat, dt = dt, stackmax = stackmax, lambda = lambda,
rmax = 5, polyOrder = 1, useSine = FALSE)
plot(hav)
document()
check()
build()
document()
check()
build()
xdat <- ECG_measurements[,"channel1"]
dt <- ECG_measurements[2,"time"] - ECG_measurements[1,"time"]
stackmax <- 25
rmax <- 5
lambda <- .001
hav <- havok(xdat = xdat, dt = dt, stackmax = stackmax, lambda = lambda,
rmax = 5, polyOrder = 1, useSine = FALSE)
plot(hav)
a <- build_hankel(xdat, 100)
b <- svd(a)
install.packages("rsvd")
library(rsvd)
?RSVD
?rsvd
document
document()
check()
build_manual()
build()
x <- rnorm(500)
build_hankel(x)
check()
build()
load_all()
build_hankel(x)
build_hankel(x, 5)
dim(build_hankel(x, 5))
dim(build_hankel(x, 500))
dim(build_hankel(x, 250))
dim(build_hankel(x, 251))
x <-rnorm(101)
dim(build_hankel(x, 5))
dim(build_hankel(x, 50))
dim(build_hankel(x, 51))
build_hankel(x, 51)
dim(build_hankel(x, 51))
dim(build_hankel(x, 50))
x <-rnorm(100)
dim(build_hankel(x, 50))
check()
dim(build_hankel(x, 50))
build_hankel()
build_hankel
check()
load("~/Downloads/results.elena.rdata")
xdat <- results.elena$Topic9
dt <- 1
stackmax <- 8
rset <- 4
lambda <- 0.050040851
hav <- havok(xdat = xdat, dt = dt, stackmax = stackmax, lambda = lambda,rmax=NA,rset=rset,
polyOrder = 1, useSine = FALSE,devMethod = "GLLA",
gllaEmbed = 3, alignSVD = TRUE)
devtools::load_all()
hav <- havok(xdat = xdat, dt = dt, stackmax = stackmax, lambda = lambda,rmax=NA,rset=rset,
polyOrder = 1, useSine = FALSE,devMethod = "GLLA",
gllaEmbed = 3, alignSVD = TRUE)
plot(hav)
#' Plotting functions for the havok package of class â€œhavok"
#'
#' @description Generic plotting function for object of class ("havok")
#' @param x A "havok" object.
#'
#' @param what See details.
#' @param ... Other calls to plot.
#' @details Arguments for \code{what} parameter:\itemize{
#' \item{\code{"interactive"} - }{An interactive plotting function.}
#' \item{\code{"reconstruction"} - }{Reconstruction of the major component of a time-series.}
#' \item{\code{"forcing"} - }{Forcing vector derived from HAVOK.}
#' \item{\code{"both"} - }{A combination of 'reconstruction' and 'forcing'.}
#' \item{\code{"U-modes"} - }{U modes of the reconstructed time series.}
#' \item{\code{"Vembedded"} - }{A 2D reconstruction of the attractor based on Eigen vectors.}
#' \item{\code{"nonlinear"} - }{A 2D reconstruction of the attractor with nonlinear regions colored red.}}
#' \item{\code{"SSmod"} - }{Ouput time series of a HAVOK state space model.}
#' \item{\code{"SSembedded"} - }{A 2D reconstruction of the attractor based a HAVOK state space model.}}
#' @examples
#'
#' \dontrun{
#'#Generate Data
#'##Set Lorenz Parameters
#'parameters <- c(s = 10, r = 28, b = 8/3)
#'n <- 3
#'state <- c(X = -8, Y = 8, Z =27) ##Inital Values
#'
#'#Intergrate
#'dt <- 0.001
#'tspan <- seq(dt, 200, dt)
#'N <- length(tspan)
#'
#'Lorenz <- function(t, state, parameters) {
#'  with(as.list(c(state, parameters)), {
#'    dX <- s * (Y - X)
#'    dY <- X * (r - Z) - Y
#'    dZ <- X * Y - b * Z
#'    list(c(dX, dY, dZ))
#'  })
#'}
#'
#'out <- ode(y = state, times = tspan, func = Lorenz, parms = parameters, rtol = 1e-12, atol = 1e-12)
#'xdat <- out[, "X"]
#'t <- out[, "time"]
#'hav <- havok(xdat = xdat, dt = dt, stackmax = 100, lambda = 0,
#'             rmax = 15, polyOrder = 1, useSine = FALSE)
#'
#'plot(hav)
#'}
###################################
## S3 method for class "havok"
#' @export
plot.havok <- function(x, what = "interactive", ...) {
if (what == "interactive"){
cat("--- Please select a plot type by number ---\n
Plot Types:
1 - V1 Reconstruction  5 - V Embedded Attractor
2 - Forcing            6 - Strongly Nonlinear Region
3 - Both               7 - SS Model Output
4 - U-modes            8 - SS Embedded Attractor")
repeat {
whatPlot <- readline("Please select a number (press esc to exit): ")
if (!whatPlot %in% 1:8){
stop("Please pick a number between 1 and 8")
}
if (whatPlot == 1){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$Vr[,1], type = "l", xlab = "Time", ylab = "V1", ...)
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
if (whatPlot == 2){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$Vr[,x$r], type = "l", xlab = "Time", ylab = "Forcing", ...)
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
if (whatPlot == 3){
graphics::par(mfrow=c(2,1), mai = c(0.5, 1.0, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$Vr[,1], type = "l", xlab = NA, ylab = "V1", ...)
graphics::par(mai = c(1, 1.0, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$Vr[,x$r], type = "l", xlab = "Time", ylab = "Forcing", ...)
graphics::par(mfrow=c(1,1), mai = c(1.02, 0.82, 0.82, 0.42))
}
if (whatPlot == 4){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
plotBuff <- (.1 * (max(x$U[, 1:x$r]) - min(x$U[, 1:x$r])))
graphics::plot(x$U[,1], ylab = "Ur", xlab = "Time",
type = "l",
xaxt = "n",
col = grDevices::rainbow(x$r)[1],
ylim = c(min(x$U[,1:x$r]) - (.1*plotBuff), max(x$U[,1:x$r]) + (.1*plotBuff)))
graphics::axis(1, at = seq(0, ncol(x$U)-1, length.out = min(10, x$params["stackmax",])),
labels = round(seq(0, x$params["stackmax",], length.out = min(10, x$params["stackmax",]))))
for (i in 1:x$r){
graphics::lines(x$U[,i], col = grDevices::rainbow(x$r, alpha = 1/sqrt(i))[i])
}
if (x$r <= 6){
graphics::legend("topleft",
fill = grDevices::rainbow(x$r, alpha = 1/sqrt(1:x$r)),
legend = paste("r = ", 1:x$r, sep = ""))
}
if (x$r > 6){
graphics::legend("topleft",
fill = grDevices::rainbow(x$r, alpha = 1/sqrt(1:x$r))[c(1:6,x$r)],
legend = c(paste("r = ", 1:5, sep = ""),
"...",
paste("r = ", x$r, sep = ""))
)
}
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
if (whatPlot == 5){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$Vr[,1], x$Vr[,2], type = "l", xlab = "V1", ylab = "V2", ...)
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
if (whatPlot == 6){
havForce <- active_forcing(x)
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$Vr[,1], x$Vr[,2], type = "l", xlab = "V1", ylab = "V2", ...)
graphics::segments(utils::head(x$Vr[,1], -1), utils::head(x$Vr[,2], -1), x$Vr[,1][-1], x$Vr[,2][-1], ifelse(havForce$active==1,"red","black"))
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
if (whatPlot == 7){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$havokSS$y[1,], type = "l", xlab = "Time", ylab = "y", ...)
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
if (whatPlot == 8){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$havokSS$y[1,], x$havokSS$y[2,], type = "l", xlab = "y1", ylab = "y2", ...)
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
}
}
if (what == "reconstruction"){
graphics::plot(x$havokSS$t, x$Vr[,1], type = "l", xlab = NA, ylab = "V1", ...)
}
if (what == "forcing"){
graphics::plot(x$havokSS$t, x$Vr[,x$r], type = "l", xlab = "Time", ylab = "Forcing", ...)
}
if (what == "both") {
graphics::par(mfrow=c(2,1), mai = c(0.5, 1.0, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$Vr[,1], type = "l", xlab = NA, ylab = "V1", ...)
graphics::par(mai = c(1, 1.0, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$Vr[,x$r], type = "l", xlab = "Time", ylab = "Forcing", ...)
graphics::par(mfrow=c(1,1), mai = c(1.02, 0.82, 0.82, 0.42))
}
if (what == "U-modes") {
plotBuff <- (.1 * (max(x$U[, 1:x$r]) - min(x$U[, 1:x$r])))
graphics::plot(x$U[,1], ylab = "Ur", xlab = "Time",
type = "l",
xaxt = "n",
col = grDevices::rainbow(x$r)[1],
ylim = c(min(x$U[,1:x$r]) - (.1*plotBuff), max(x$U[,1:x$r]) + (.1*plotBuff)))
graphics::axis(1, at = seq(0, ncol(x$U)-1, length.out = min(10, x$params["stackmax",])),
labels = round(seq(0, x$params["stackmax",], length.out = min(10, x$params["stackmax",]))))
for (i in 1:x$r){
graphics::lines(x$U[,i], col = grDevices::rainbow(x$r, alpha = 1/sqrt(i))[i])
}
if (x$r < 6){
graphics::legend("topleft",
fill = grDevices::rainbow(x$r, alpha = 1/sqrt(1:x$r)),
legend = paste("r = ", 1:x$r, sep = ""))
}
if (x$r >= 6){
graphics::legend("topleft",
fill = grDevices::rainbow(x$r, alpha = 1/sqrt(1:x$r))[c(1:6, x$r)],
legend = c(paste("r = ", 1:5, sep = ""),
"...",
paste("r = ", x$r, sep = ""))
)
}
}
if (what == "Vembedded"){
graphics::plot(x$Vr[,1], x$Vr[,2], type = "l", xlab = "V1", ylab = "V2", ...)
}
if (what == "nonlinear"){
havForce <- active_forcing(x)
graphics::plot(x$Vr[,1], x$Vr[,2], type = "l", xlab = "V1", ylab = "V2", ...)
graphics::segments(utils::head(x$Vr[,1], -1), utils::head(x$Vr[,2], -1), x$Vr[,1][-1], x$Vr[,2][-1], ifelse(havForce$active==1,"red","black"))
}
if (what == "SSmod"){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$havokSS$y[1,], type = "l", xlab = "Time", ylab = "y", ...)
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
if (what == "SSembedded"){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$havokSS$y[1,], x$havokSS$y[2,], type = "l", xlab = "y1", ylab = "y2", ...)
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
}
# Copyright 2020 Robert Glenn Moulder Jr. & Elena Martynova
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
plot(hav)
x <- hav
ncol(x$U)
seq(0, ncol(x$U)-1, length.out = min(10, x$params["stackmax",]))
seq(0, ncol(x$U)-1, length.out = min(10, ncol(x$U)-1))
#' Plotting functions for the havok package of class â€œhavok"
#'
#' @description Generic plotting function for object of class ("havok")
#' @param x A "havok" object.
#'
#' @param what See details.
#' @param ... Other calls to plot.
#' @details Arguments for \code{what} parameter:\itemize{
#' \item{\code{"interactive"} - }{An interactive plotting function.}
#' \item{\code{"reconstruction"} - }{Reconstruction of the major component of a time-series.}
#' \item{\code{"forcing"} - }{Forcing vector derived from HAVOK.}
#' \item{\code{"both"} - }{A combination of 'reconstruction' and 'forcing'.}
#' \item{\code{"U-modes"} - }{U modes of the reconstructed time series.}
#' \item{\code{"Vembedded"} - }{A 2D reconstruction of the attractor based on Eigen vectors.}
#' \item{\code{"nonlinear"} - }{A 2D reconstruction of the attractor with nonlinear regions colored red.}}
#' \item{\code{"SSmod"} - }{Ouput time series of a HAVOK state space model.}
#' \item{\code{"SSembedded"} - }{A 2D reconstruction of the attractor based a HAVOK state space model.}}
#' @examples
#'
#' \dontrun{
#'#Generate Data
#'##Set Lorenz Parameters
#'parameters <- c(s = 10, r = 28, b = 8/3)
#'n <- 3
#'state <- c(X = -8, Y = 8, Z =27) ##Inital Values
#'
#'#Intergrate
#'dt <- 0.001
#'tspan <- seq(dt, 200, dt)
#'N <- length(tspan)
#'
#'Lorenz <- function(t, state, parameters) {
#'  with(as.list(c(state, parameters)), {
#'    dX <- s * (Y - X)
#'    dY <- X * (r - Z) - Y
#'    dZ <- X * Y - b * Z
#'    list(c(dX, dY, dZ))
#'  })
#'}
#'
#'out <- ode(y = state, times = tspan, func = Lorenz, parms = parameters, rtol = 1e-12, atol = 1e-12)
#'xdat <- out[, "X"]
#'t <- out[, "time"]
#'hav <- havok(xdat = xdat, dt = dt, stackmax = 100, lambda = 0,
#'             rmax = 15, polyOrder = 1, useSine = FALSE)
#'
#'plot(hav)
#'}
###################################
## S3 method for class "havok"
#' @export
plot.havok <- function(x, what = "interactive", ...) {
if (what == "interactive"){
cat("--- Please select a plot type by number ---\n
Plot Types:
1 - V1 Reconstruction  5 - V Embedded Attractor
2 - Forcing            6 - Strongly Nonlinear Region
3 - Both               7 - SS Model Output
4 - U-modes            8 - SS Embedded Attractor")
repeat {
whatPlot <- readline("Please select a number (press esc to exit): ")
if (!whatPlot %in% 1:8){
stop("Please pick a number between 1 and 8")
}
if (whatPlot == 1){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$Vr[,1], type = "l", xlab = "Time", ylab = "V1", ...)
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
if (whatPlot == 2){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$Vr[,x$r], type = "l", xlab = "Time", ylab = "Forcing", ...)
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
if (whatPlot == 3){
graphics::par(mfrow=c(2,1), mai = c(0.5, 1.0, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$Vr[,1], type = "l", xlab = NA, ylab = "V1", ...)
graphics::par(mai = c(1, 1.0, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$Vr[,x$r], type = "l", xlab = "Time", ylab = "Forcing", ...)
graphics::par(mfrow=c(1,1), mai = c(1.02, 0.82, 0.82, 0.42))
}
if (whatPlot == 4){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
plotBuff <- (.1 * (max(x$U[, 1:x$r]) - min(x$U[, 1:x$r])))
graphics::plot(x$U[,1], ylab = "Ur", xlab = "Time",
type = "l",
xaxt = "n",
col = grDevices::rainbow(x$r)[1],
ylim = c(min(x$U[,1:x$r]) - (.1*plotBuff), max(x$U[,1:x$r]) + (.1*plotBuff)))
graphics::axis(1, at = seq(0, ncol(x$U)-1, length.out = min(10, ncol(x$U)-1)),
labels = round(seq(0, x$params["stackmax",], length.out = min(10, x$params["stackmax",]))))
for (i in 1:x$r){
graphics::lines(x$U[,i], col = grDevices::rainbow(x$r, alpha = 1/sqrt(i))[i])
}
if (x$r <= 6){
graphics::legend("topleft",
fill = grDevices::rainbow(x$r, alpha = 1/sqrt(1:x$r)),
legend = paste("r = ", 1:x$r, sep = ""))
}
if (x$r > 6){
graphics::legend("topleft",
fill = grDevices::rainbow(x$r, alpha = 1/sqrt(1:x$r))[c(1:6,x$r)],
legend = c(paste("r = ", 1:5, sep = ""),
"...",
paste("r = ", x$r, sep = ""))
)
}
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
if (whatPlot == 5){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$Vr[,1], x$Vr[,2], type = "l", xlab = "V1", ylab = "V2", ...)
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
if (whatPlot == 6){
havForce <- active_forcing(x)
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$Vr[,1], x$Vr[,2], type = "l", xlab = "V1", ylab = "V2", ...)
graphics::segments(utils::head(x$Vr[,1], -1), utils::head(x$Vr[,2], -1), x$Vr[,1][-1], x$Vr[,2][-1], ifelse(havForce$active==1,"red","black"))
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
if (whatPlot == 7){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$havokSS$y[1,], type = "l", xlab = "Time", ylab = "y", ...)
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
if (whatPlot == 8){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$havokSS$y[1,], x$havokSS$y[2,], type = "l", xlab = "y1", ylab = "y2", ...)
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
}
}
if (what == "reconstruction"){
graphics::plot(x$havokSS$t, x$Vr[,1], type = "l", xlab = NA, ylab = "V1", ...)
}
if (what == "forcing"){
graphics::plot(x$havokSS$t, x$Vr[,x$r], type = "l", xlab = "Time", ylab = "Forcing", ...)
}
if (what == "both") {
graphics::par(mfrow=c(2,1), mai = c(0.5, 1.0, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$Vr[,1], type = "l", xlab = NA, ylab = "V1", ...)
graphics::par(mai = c(1, 1.0, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$Vr[,x$r], type = "l", xlab = "Time", ylab = "Forcing", ...)
graphics::par(mfrow=c(1,1), mai = c(1.02, 0.82, 0.82, 0.42))
}
if (what == "U-modes") {
plotBuff <- (.1 * (max(x$U[, 1:x$r]) - min(x$U[, 1:x$r])))
graphics::plot(x$U[,1], ylab = "Ur", xlab = "Time",
type = "l",
xaxt = "n",
col = grDevices::rainbow(x$r)[1],
ylim = c(min(x$U[,1:x$r]) - (.1*plotBuff), max(x$U[,1:x$r]) + (.1*plotBuff)))
graphics::axis(1, at = seq(0, ncol(x$U)-1, length.out = min(10, x$params["stackmax",])),
labels = round(seq(0, x$params["stackmax",], length.out = min(10, x$params["stackmax",]))))
for (i in 1:x$r){
graphics::lines(x$U[,i], col = grDevices::rainbow(x$r, alpha = 1/sqrt(i))[i])
}
if (x$r < 6){
graphics::legend("topleft",
fill = grDevices::rainbow(x$r, alpha = 1/sqrt(1:x$r)),
legend = paste("r = ", 1:x$r, sep = ""))
}
if (x$r >= 6){
graphics::legend("topleft",
fill = grDevices::rainbow(x$r, alpha = 1/sqrt(1:x$r))[c(1:6, x$r)],
legend = c(paste("r = ", 1:5, sep = ""),
"...",
paste("r = ", x$r, sep = ""))
)
}
}
if (what == "Vembedded"){
graphics::plot(x$Vr[,1], x$Vr[,2], type = "l", xlab = "V1", ylab = "V2", ...)
}
if (what == "nonlinear"){
havForce <- active_forcing(x)
graphics::plot(x$Vr[,1], x$Vr[,2], type = "l", xlab = "V1", ylab = "V2", ...)
graphics::segments(utils::head(x$Vr[,1], -1), utils::head(x$Vr[,2], -1), x$Vr[,1][-1], x$Vr[,2][-1], ifelse(havForce$active==1,"red","black"))
}
if (what == "SSmod"){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$havokSS$t, x$havokSS$y[1,], type = "l", xlab = "Time", ylab = "y", ...)
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
if (what == "SSembedded"){
graphics::par(mai = c(0.9, 0.8, 0.1, 0.1))
graphics::plot(x$havokSS$y[1,], x$havokSS$y[2,], type = "l", xlab = "y1", ylab = "y2", ...)
graphics::par(mai = c(1.02, 0.82, 0.82, 0.42))
}
}
# Copyright 2020 Robert Glenn Moulder Jr. & Elena Martynova
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
plot(hav)
ncol(x$U)
ncol(x$U)-1
x$U
x <- hav
