#' Structured Hankel Alternative View of Koopman (sHAVOK) Analysis
#'
#' @description Data-driven decomposition of chaotic time series into an intermittently
#' forced linear system. HAVOK combines delay embedding and Koopman theory to decompose
#' chaotic dynamics into a linear model in the leading delay coordinates with forcing by
#' low-energy delay coordinates. Forcing activity demarcates coherent phase space regions
#' where the dynamics are approximately linear from those that are strongly nonlinear.
#' @usage s_havok(xdat, dt = 1, stackmax = 100, lambda = 0, center = TRUE,
#'              rmax = 15, rset = NA, rout = NA, polyOrder = 1,
#'              useSine = FALSE, discrete = FALSE, devMethod = c("FOCD", "GLLA"),
#'              gllaEmbed = NA, alignSVD = TRUE)
#' @param xdat A vector of equally spaced measurements over time.
#' @param dt A numeric value indicating the time-lag between two subsequent time series measurements.
#' @param stackmax An integer; number of shift-stacked rows.
#' @param lambda A numeric value; sparsification threshold.
#' @param center Logical; Should \code{xdat} be centered around 0?
#' @param rmax An integer; maximum number of singular vectors to include.
#' @param rset An integer; specific number of singular vectors to include.
#' @param rout An integer or vector of integers; excludes columns of singular values from analysis.
#' @param polyOrder An integer from 0 to 5; the highest degree of polynomials
#' included in the matrix of candidate functions.
#' @param useSine Logical; Should sine and cosine functions
#' of variables should be added to the library of potential candidate functions?
#' If TRUE, candidate function matrix is augmented with sine and cosine functions
#' of integer multiples 1 through 10.
#' @param discrete Logical; Is the underlying system discrete?
#' @param devMethod A character string; One of either \code{"FOCD"} for fourth order central difference or \code{"GLLA"} for generalized local linear approximation.
#' @param gllaEmbed An integer; the embedding dimension used for \code{devMethod = "GLLA"}.
#' @param alignSVD Logical; Whether the singular vectors should be aligned with the data.
#' @return An object of class 'havok' with the following components: \itemize{
#' \item{\code{havokSS} - }{A HAVOK analysis generated state space model with its time history.}
#' \item{\code{params} - }{A matrix of parameter values used for this function.}
#' \item{\code{dVrdt} - }{A matrix of first order derivatives of the reduced rank V matrix with respect to time.}
#' \item{\code{r} - }{Estimated optimal number singular vectors to include in analysis.}
#' \item{\code{sys} - }{HAVOK model represented in state-space form.}
#' \item{\code{normTheta} - }{Normalized matrix of candidate functions obtained from \code{\link{pool_data}}.}
#' \item{\code{Xi} - }{A matrix of sparse coefficients obtained from \code{\link{sparsify_dynamics}}.}
#' \item{\code{Ur} - }{The reduced rank U matrix of the SVD of the Hankel matrix of the time series.}
#' \item{\code{sigsr} - }{Values of the diagonal of the reduced rank \eqn{\Sigma} matrix of the SVD of the Hankel matrix of the time series.}
#' \item{\code{Vr} - }{The reduced rank V matrix of the SVD of the Hankel matrix of the time series.}}
#' @references S. L. Brunton, B. W. Brunton, J. L. Proctor, E. Kaiser, and J. N. Kutz,
#' "Chaos as an intermittently forced linear system," Nature Communications, 8(19):1-9, 2017.
#' @examples
#' \dontrun{
#'#Lorenz Attractor
#'#Generate Data
#'##Set Lorenz Parameters
#'parameters <- c(s = 10, r = 28, b = 8/3)
#'n <- 3
#'state <- c(X = -8, Y = 8, Z =27) ##Inital Values
#'
#'#Intergrate
#'dt <- 0.001
#'tspan <- seq(dt, 200, dt)
#'N <- length(tspan)
#'
#'Lorenz <- function(t, state, parameters) {
#'  with(as.list(c(state, parameters)), {
#'    dX <- s * (Y - X)
#'    dY <- X * (r - Z) - Y
#'    dZ <- X * Y - b * Z
#'    list(c(dX, dY, dZ))
#'  })
#'}
#'
#'out <- ode(y = state, times = tspan, func = Lorenz, parms = parameters, rtol = 1e-12, atol = 1e-12)
#'xdat <- out[, "X"]
#'
#'hav <- havok(xdat = xdat, dt = dt, stackmax = 100, lambda = 0,
#'             rmax = 15, polyOrder = 1, useSine = FALSE)
#'
#'# ECG Example
#'
#'data(ECG_measurements)
#'
#'xdat <- ECG_measurements[,"channel1"]
#'dt <- ECG_measurements[2,"time"] - ECG_measurements[1,"time"]
#'stackmax <- 25
#'rmax <- 5
#'lambda <- .001
#'hav <- havok(xdat = xdat, dt = dt, stackmax = stackmax, lambda = lambda,
#'             rmax = 5, polyOrder = 1, useSine = FALSE)
#'plot(hav)
#'}
###################################

#' @export

s_havok <- function(xdat, dt = 1, stackmax = 100,
                    r = NA, centerH = TRUE, alignSVD = TRUE) {

  # Error catch

  # Create Hankel matrix
  H <- build_hankel(x = xdat, stackmax = stackmax)

  # Apply SVD Centering
  if (centerH == TRUE){
    H <- apply(H, 2, function(y) return(y - mean(y)))
  }

  # Subset Hankel matrix
  H1 <- H[,1:(ncol(H)-1)]
  H2 <- H[,2:(ncol(H))]

  # Perform SVD of each Hankel matrix
  # Align and reduce rank of SVD
  if (alignSVD == TRUE){
    USV1 <- svd_align(H1, r = r)
    U1 <- USV1$u
    sigs1 <- USV1$d
    V1 <- USV1$v

    USV2 <- svd_align(H2, r = r)
    U2 <- USV2$u
    sigs2 <- USV2$d
    V2 <- USV2$v
  } else {
    USV1 <- svd(H1)
    U1 <- USV1$u[,1:r]
    sigs1 <- USV1$d[1:r]
    V1 <- USV1$v[,1:r]

    USV2 <- svd(H2)
    U2 <- USV2$u[,1:r]
    sigs2 <- USV2$d[1:r]
    V2 <- USV2$v[,1:r]
  }

  V <- V1[,1:(r-1)]
  dV <- (V2 - V1)/dt

}












